package binaryoperation;

/**
 * Leetcode5533: 使整数变为0的最少操作次数
 * - 思路:
 *      - 证明: 当 n == 2^(k)时， res = 2^(k + 1) - 1
 *          - 假设 n = 100...000, np = 010...000
 *              即 n = 2*np
 *              根据题目规律, n -> 0 的过程必然会经过 np
 *              即 n -> np -> 0
 *          - 假设 np -> 0 需要 x 次变换
 *              即 010...000 -> 000...000 需要 x 次
 *              n -> np需要多少次呢？
 *              观察可知，n -> np 需要经过 np + n，那么有 n -> 110...000(np + n) -> np
 *              即求出 100...000 -> 110...000 需要多少次即可
 *                  由于首尾都是1，我们可以直接无视掉首尾，从而转换成: 00...000 -> 10...000 需要多少次？
 *                  这正好是 00...000 -> np，即np变成0反过来，很明显这也是 x 次
 *              所以 n -> np + n  需要 x 次
 *                  np + n -> np 需要 1 次
 *                  np -> 0      需要 x 次
 *              所以 n -> 0 需要 2*x + 1 次
 *          - 以上两步，可求出递推公式 a[k] = 2*a[k - 1] + 1
 *          - 进一步求出通项公式即可得到 res = 2^(k + 1) - 1
 *      - 状态转移:
 *          - n != 2^(k) 时， 假设 n 是这样一种形式: 11000...111001100
 *          - 最极端的，用一个例子来演示: n = 111...111
 *              100...000 -> 111...111 -> 0，即 100...000 -> 0 的变换必然会经过 111...111
 *              通过第一个假设，我们可以直接得到 100...000 -> 0 的次数，设为 y
 *              只要能得到 100...000 -> 111...111，设为 x
 *              就可以求出 111...111 -> 0 = y - x
 *          - 求 100...000 -> 111...111，第一位一样，可以转化为: 00...000 -> 11...111
 *          - 即求 11...111 -> 00...000，成功将 n -> 0 转化成 (n - highbit(n)) -> 0 的子问题
 *          - 使用递归求解即可
 */
public class Leetcode5533 {
    public int minimumOneBitOperations(int n) {
        if(n == 0) return 0;
        if(n == 1) return 1;

        int high = Integer.highestOneBit(n);
        int highbit = (int)(Math.log(n) / Math.log(2));
        return ((1 << (highbit + 1)) - 1) - minimumOneBitOperations(n ^ high);
    }
}
